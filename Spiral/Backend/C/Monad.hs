{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}

-- |
-- Module      :  Spiral.Backend.C.Monad
-- Copyright   :  (c) 2016 Drexel University
-- License     :  BSD-style
-- Maintainer  :  mainland@drexel.edu

module Spiral.Backend.C.Monad (
    Cg,
    evalCg,

    tell,
    collect,
    collectDefinitions,
    collectDefinitions_,
    collectDecls,
    collectDecls_,
    collectStms,
    collectStms_,
    collectBlock,

    inNewBlock,
    inNewBlock_,

    appendTopDef,
    appendTopDefs,
    appendTopFunDef,
    appendTopFunDefs,
    appendTopDecl,
    appendTopDecls,
    appendDecl,
    appendDecls,
    appendStm,
    appendStms,
    appendBlock,

    cacheConst,
    cacheCExp,
    lookupCExp,

    cvar
  ) where

import Control.Monad.Exception (MonadException(..))
import Control.Monad.IO.Class (MonadIO)
import Control.Monad.Trans.Class (MonadTrans(..))
import Control.Monad.State (MonadState(..),
                            StateT,
                            execStateT,
                            gets,
                            modify)
import Data.Foldable (toList)
import Data.Loc (noLoc)
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Monoid
import Data.Sequence (Seq)
import qualified Data.Sequence as Seq
import Language.C.Pretty ()
import qualified Language.C.Syntax as C
import Language.C.Quote.C

import Spiral.Backend.C.CExp
import Spiral.Backend.C.Code
import Spiral.Backend.C.Types
import Spiral.Config
import Spiral.Monad (MonadCg)
import Spiral.Trace
import Spiral.Util.Uniq

data CgState = CgState
    { -- | Generated code
      code :: Code
    , -- | Cached constants
      constCache :: Map C.Initializer C.Exp
    , -- | Cached expressions
      expCache :: Map C.Exp C.Exp
    }

defaultCgState :: CgState
defaultCgState = CgState
    { code       = mempty
    , constCache = mempty
    , expCache   = mempty
    }

-- | The 'Cg' monad transformer.
newtype Cg m a = Cg { unCg :: StateT CgState m a }
    deriving (Functor, Applicative, Monad, MonadIO,
              MonadException,
              MonadState CgState,
              MonadUnique,
              MonadTrace,
              MonadConfig)

instance MonadTrans Cg where
    lift = Cg . lift

instance MonadCg m => MonadCg (Cg m) where

-- | Evaluate a 'Cg' action and return a list of 'C.Definition's.
evalCg :: Monad m => Cg m () -> m (Seq C.Definition)
evalCg m = do
    s <- execStateT (unCg m) defaultCgState
    return $ (codeDefs . code) s <> (codeFunDefs . code) s

-- | Add generated code.
tell :: Monad m => Code -> Cg m ()
tell c = modify $ \s -> s { code = code s <> c }

-- | Collect code generated by a computation.
collect :: Monad m => Cg m a -> Cg m (Code, a)
collect m = do
    old_code <- gets code
    modify $ \s -> s { code = mempty }
    x <- m
    c <- gets code
    modify $ \s -> s { code = old_code }
    return (c, x)

-- | Collect definitions generated by a computation.
collectDefinitions :: Monad m => Cg m a -> Cg m ([C.Definition], a)
collectDefinitions m = do
    (c, x) <- collect m
    tell c { codeDefs = mempty }
    return (toList (codeDefs c), x)

-- | Collect definitions generated by a unit computation.
collectDefinitions_ :: Monad m => Cg m () -> Cg m [C.Definition]
collectDefinitions_ m = fst <$> collectDefinitions m

-- | Collect declarations generated by a computation.
collectDecls :: Monad m => Cg m a -> Cg m ([C.InitGroup], a)
collectDecls m = do
    (c, x) <- collect m
    tell c { codeDecls = mempty }
    return (toList (codeDecls c), x)

-- | Collect declarations generated by a unit computation.
collectDecls_ :: Monad m => Cg m () -> Cg m [C.InitGroup]
collectDecls_ m = fst <$> collectDecls m

-- | Collect statements generated by a computation.
collectStms :: Monad m => Cg m a -> Cg m ([C.Stm], a)
collectStms m = do
    (c, x) <- collect m
    tell c { codeStms = mempty }
    return (toList (codeStms c), x)

-- | Collect statements generated by a unit computation.
collectStms_ :: Monad m => Cg m () -> Cg m [C.Stm]
collectStms_ m = fst <$> collectStms m

-- | Collect a block of code generated by a computation.
collectBlock :: Monad m => Cg m a -> Cg m (Seq C.InitGroup, Seq C.Stm, a)
collectBlock m = do
    (c, x) <- collect m
    tell c { codeDecls = mempty
           , codeStms  = mempty
           }
    return (codeDecls c, codeStms c, x)

inNewBlock :: Monad m => Cg m a -> Cg m ([C.BlockItem], a)
inNewBlock m = do
    (decls, stms, x) <- collectBlock m
    return ((map C.BlockDecl . toList) decls ++
            (map C.BlockStm .  toList) stms
           ,x)

inNewBlock_ :: Monad m => Cg m a -> Cg m [C.BlockItem]
inNewBlock_ m =
    fst <$> inNewBlock m

-- | Append a top-level definition.
appendTopDef :: Monad m => C.Definition -> Cg m ()
appendTopDef cdef =
  tell mempty { codeDefs = Seq.singleton cdef }

-- | Append top-level definitions.
appendTopDefs :: Monad m => [C.Definition] -> Cg m ()
appendTopDefs cdefs =
  tell mempty { codeDefs = Seq.fromList cdefs }

-- | Append a top-level function definition. Function definitions appear after
-- regular top-level definitions.
appendTopFunDef :: Monad m => C.Definition -> Cg m ()
appendTopFunDef cdef =
  tell mempty { codeFunDefs = Seq.singleton cdef }

-- | Append top-level functions definitions.
appendTopFunDefs :: Monad m => [C.Definition] -> Cg m ()
appendTopFunDefs cdefs =
  tell mempty { codeFunDefs = Seq.fromList cdefs }

appendTopDecl :: Monad m => C.InitGroup -> Cg m ()
appendTopDecl cdecl =
  tell mempty { codeDefs = Seq.singleton (C.DecDef cdecl noLoc) }

appendTopDecls :: Monad m => [C.InitGroup] -> Cg m ()
appendTopDecls cdecls =
  tell mempty { codeDefs = Seq.fromList [C.DecDef decl noLoc | decl <- cdecls] }

appendDecl :: Monad m => C.InitGroup -> Cg m ()
appendDecl cdecl = tell mempty { codeDecls = Seq.singleton cdecl }

appendDecls :: Monad m => [C.InitGroup] -> Cg m ()
appendDecls cdecls = tell mempty { codeDecls = Seq.fromList cdecls }

appendStm :: Monad m => C.Stm -> Cg m ()
appendStm cstm = tell mempty { codeStms = Seq.singleton cstm }

appendStms :: Monad m => [C.Stm] -> Cg m ()
appendStms cstms = tell mempty { codeStms = Seq.fromList cstms }

appendBlock :: Monad m => [C.BlockItem] -> Cg m ()
appendBlock citems
    | all isBlockStm citems = appendStms [stm | C.BlockStm stm <- citems]
    | otherwise             = appendStm [cstm|{ $items:citems }|]
  where
    isBlockStm :: C.BlockItem -> Bool
    isBlockStm C.BlockStm{} = True
    isBlockStm _            = False

cacheConst :: MonadUnique m
           => C.Initializer
           -> C.Type
           -> Cg m C.Exp
cacheConst cinits ctau = do
    maybe_ce <- gets (Map.lookup cinits . constCache)
    case maybe_ce of
      Just ce -> return ce
      Nothing -> do ctemp  <- cvar "m"
                    let ce =  [cexp|$id:ctemp|]
                    appendTopDecl [cdecl|$ty:ctau $id:ctemp = $init:cinits;|]
                    modify $ \s -> s { constCache = Map.insert cinits ce (constCache s) }
                    return ce

-- | Cache a 'CExp'. This generates a local binding for the value of the 'CExp'.
cacheCExp :: forall a m . (ToCType a, MonadUnique m)
          => CExp a
          -> Cg m (CExp a)
cacheCExp e = do
    maybe_ce' <- gets (Map.lookup ce . expCache)
    case maybe_ce' of
      Just ce' -> return $ CExp ce'
      Nothing  -> do ce' <- go e
                     modify $ \s -> s { expCache = Map.insert ce ce' (expCache s) }
                     return $ CExp ce'
  where
    ce :: C.Exp
    ce = toExp e noLoc

    ctau :: C.Type
    ctau = toCType (undefined :: a)

    go :: CExp a -> Cg m C.Exp
    go CInt{} =
        return ce

    go CDouble{} =
        return ce

    go (CComplex CDouble{} CDouble{}) =
        return ce

    go (CExp [cexp|$id:_|]) =
        return ce

    go (CInit ini) =
        cacheConst ini ctau

    go _ = do
        ctemp   <- cvar "x"
        let ce' =  [cexp|$id:ctemp|]
        appendDecl [cdecl|$ty:ctau $id:ctemp;|]
        appendStm [cstm|$id:ctemp = $e;|]
        return ce'

-- | Look up the cached C expression corresponding to a 'CExp'. If the 'CExp'
-- has not been cached, we return it without caching it.
lookupCExp :: forall a m . (ToCType a, MonadUnique m)
           => CExp a
           -> Cg m (CExp a)
lookupCExp e = do
    maybe_ce' <- gets (Map.lookup ce . expCache)
    case maybe_ce' of
      Just ce' -> return $ CExp ce'
      Nothing  -> return e
  where
    ce :: C.Exp
    ce = toExp e noLoc

-- | Generate a unique C identifier name using the given prefix.
cvar :: MonadUnique m => String -> Cg m C.Id
cvar = gensym
