{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}

-- |
-- Module      :  Spiral.Backend.C.Monad
-- Copyright   :  (c) 2016 Drexel University
-- License     :  BSD-style
-- Maintainer  :  mainland@drexel.edu

module Spiral.Backend.C.Monad (
    Cg,
    evalCg,

    tell,
    collect,
    collectDefinitions,
    collectDefinitions_,
    collectDecls,
    collectDecls_,
    collectStms,
    collectStms_,
    collectBlock,

    inNewBlock,
    inNewBlock_,

    appendTopDef,
    appendTopDefs,
    appendTopFunDef,
    appendTopFunDefs,
    appendTopDecl,
    appendTopDecls,
    appendDecl,
    appendDecls,
    appendStm,
    appendStms,
    appendBlock,

    cacheConst,

    cvar
  ) where

import Control.Monad.Exception (MonadException(..))
import Control.Monad.IO.Class (MonadIO)
import Control.Monad.Trans.Class (MonadTrans(..))
import Control.Monad.State (MonadState(..),
                            StateT,
                            execStateT,
                            gets,
                            modify)
import Data.Foldable (toList)
import Data.Loc (noLoc)
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Monoid
import Data.Sequence (Seq)
import qualified Data.Sequence as Seq
import Language.C.Pretty ()
import qualified Language.C.Syntax as C
import Language.C.Quote.C

import Spiral.Backend.C.Code
import Spiral.Config
import Spiral.Trace
import Spiral.Util.Uniq

data CgState = CgState
    { -- | Generated code
      code :: Code
    , -- | Cached constants
      constCache :: Map C.Initializer C.Exp
    }

defaultCgState :: CgState
defaultCgState = CgState
    { code       = mempty
    , constCache = mempty
    }

-- | The 'Cg' monad transformer.
newtype Cg m a = Cg { unCg :: StateT CgState m a }
    deriving (Functor, Applicative, Monad, MonadIO,
              MonadException,
              MonadState CgState,
              MonadUnique,
              MonadTrace,
              MonadConfig)

instance MonadTrans Cg where
    lift = Cg . lift

-- | Evaluate a 'Cg' action and return a list of 'C.Definition's.
evalCg :: Monad m => Cg m () -> m (Seq C.Definition)
evalCg m = do
    s <- execStateT (unCg m) defaultCgState
    return $ (codeDefs . code) s <> (codeFunDefs . code) s

-- | Add generated code.
tell :: Monad m => Code -> Cg m ()
tell c = modify $ \s -> s { code = code s <> c }

-- | Collect code generated by a computation.
collect :: Monad m => Cg m a -> Cg m (Code, a)
collect m = do
    old_code <- gets code
    modify $ \s -> s { code = mempty }
    x <- m
    c <- gets code
    modify $ \s -> s { code = old_code }
    return (c, x)

-- | Collect definitions generated by a computation.
collectDefinitions :: Monad m => Cg m a -> Cg m ([C.Definition], a)
collectDefinitions m = do
    (c, x) <- collect m
    tell c { codeDefs = mempty }
    return (toList (codeDefs c), x)

-- | Collect definitions generated by a unit computation.
collectDefinitions_ :: Monad m => Cg m () -> Cg m [C.Definition]
collectDefinitions_ m = fst <$> collectDefinitions m

-- | Collect declarations generated by a computation.
collectDecls :: Monad m => Cg m a -> Cg m ([C.InitGroup], a)
collectDecls m = do
    (c, x) <- collect m
    tell c { codeDecls = mempty }
    return (toList (codeDecls c), x)

-- | Collect declarations generated by a unit computation.
collectDecls_ :: Monad m => Cg m () -> Cg m [C.InitGroup]
collectDecls_ m = fst <$> collectDecls m

-- | Collect statements generated by a computation.
collectStms :: Monad m => Cg m a -> Cg m ([C.Stm], a)
collectStms m = do
    (c, x) <- collect m
    tell c { codeStms = mempty }
    return (toList (codeStms c), x)

-- | Collect statements generated by a unit computation.
collectStms_ :: Monad m => Cg m () -> Cg m [C.Stm]
collectStms_ m = fst <$> collectStms m

-- | Collect a block of code generated by a computation.
collectBlock :: Monad m => Cg m a -> Cg m (Seq C.InitGroup, Seq C.Stm, a)
collectBlock m = do
    (c, x) <- collect m
    tell c { codeDecls = mempty
           , codeStms  = mempty
           }
    return (codeDecls c, codeStms c, x)

inNewBlock :: Monad m => Cg m a -> Cg m ([C.BlockItem], a)
inNewBlock m = do
    (decls, stms, x) <- collectBlock m
    return ((map C.BlockDecl . toList) decls ++
            (map C.BlockStm .  toList) stms
           ,x)

inNewBlock_ :: Monad m => Cg m a -> Cg m [C.BlockItem]
inNewBlock_ m =
    fst <$> inNewBlock m

-- | Append a top-level definition.
appendTopDef :: Monad m => C.Definition -> Cg m ()
appendTopDef cdef =
  tell mempty { codeDefs = Seq.singleton cdef }

-- | Append top-level definitions.
appendTopDefs :: Monad m => [C.Definition] -> Cg m ()
appendTopDefs cdefs =
  tell mempty { codeDefs = Seq.fromList cdefs }

-- | Append a top-level function definition. Function definitions appear after
-- regular top-level definitions.
appendTopFunDef :: Monad m => C.Definition -> Cg m ()
appendTopFunDef cdef =
  tell mempty { codeFunDefs = Seq.singleton cdef }

-- | Append top-level functions definitions.
appendTopFunDefs :: Monad m => [C.Definition] -> Cg m ()
appendTopFunDefs cdefs =
  tell mempty { codeFunDefs = Seq.fromList cdefs }

appendTopDecl :: Monad m => C.InitGroup -> Cg m ()
appendTopDecl cdecl =
  tell mempty { codeDefs = Seq.singleton (C.DecDef cdecl noLoc) }

appendTopDecls :: Monad m => [C.InitGroup] -> Cg m ()
appendTopDecls cdecls =
  tell mempty { codeDefs = Seq.fromList [C.DecDef decl noLoc | decl <- cdecls] }

appendDecl :: Monad m => C.InitGroup -> Cg m ()
appendDecl cdecl = tell mempty { codeDecls = Seq.singleton cdecl }

appendDecls :: Monad m => [C.InitGroup] -> Cg m ()
appendDecls cdecls = tell mempty { codeDecls = Seq.fromList cdecls }

appendStm :: Monad m => C.Stm -> Cg m ()
appendStm cstm = tell mempty { codeStms = Seq.singleton cstm }

appendStms :: Monad m => [C.Stm] -> Cg m ()
appendStms cstms = tell mempty { codeStms = Seq.fromList cstms }

appendBlock :: Monad m => [C.BlockItem] -> Cg m ()
appendBlock citems
    | all isBlockStm citems = appendStms [stm | C.BlockStm stm <- citems]
    | otherwise             = appendStm [cstm|{ $items:citems }|]
  where
    isBlockStm :: C.BlockItem -> Bool
    isBlockStm C.BlockStm{} = True
    isBlockStm _            = False

cacheConst :: MonadUnique m
           => C.Initializer
           -> C.Type
           -> Cg m C.Exp
cacheConst cinits ctau = do
    maybe_ce <- gets (Map.lookup cinits . constCache)
    case maybe_ce of
      Just ce -> return ce
      Nothing -> do ctemp  <- cvar "m"
                    let ce =  [cexp|$id:ctemp|]
                    appendTopDecl [cdecl|$ty:ctau $id:ctemp = $init:cinits;|]
                    modify $ \s -> s { constCache = Map.insert cinits ce (constCache s) }
                    return ce

-- | Generate a unique C identifier name using the given prefix.
cvar :: MonadUnique m => String -> Cg m C.Id
cvar = gensym
