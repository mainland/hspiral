{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}

-- |
-- Module      :  Spiral.Backend.C.Monad
-- Copyright   :  (c) 2016 Drexel University
-- License     :  BSD-style
-- Maintainer  :  mainland@drexel.edu

module Spiral.Backend.C.Monad (
    Cg,
    evalCg,

    tell,
    collect,
    collectDefinitions,
    collectDefinitions_,
    collectDecls,
    collectDecls_,
    collectStms,
    collectStms_,
    collectBlock,

    inNewBlock,
    inNewBlock_,

    appendTopDef,
    appendTopDefs,
    appendTopFunDef,
    appendTopFunDefs,
    appendTopDecl,
    appendTopDecls,
    appendDecl,
    appendDecls,
    appendStm,
    appendStms,
    appendBlock,

    lookupMatrix,
    cacheMatrix
  ) where

import Control.Monad.Exception (MonadException(..))
import Control.Monad.IO.Class (MonadIO)
import Control.Monad.Trans.Class (MonadTrans(..))
import Control.Monad.State (MonadState(..),
                            StateT,
                            execStateT,
                            gets,
                            modify)
import Data.Complex
import Data.Foldable (toList)
import Data.Loc (noLoc)
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Monoid
import Data.Sequence (Seq)
import qualified Data.Sequence as Seq
import Language.C.Pretty ()
import qualified Language.C.Syntax as C
import Language.C.Quote.C

import Spiral.Backend.C.CExp
import Spiral.Backend.C.Code
import Spiral.Config
import Spiral.Exp
import Spiral.SPL
import Spiral.Trace
import Spiral.Util.Uniq

data CgState = CgState
    { -- | Generated code
      code :: Code
    , -- | Cached matrices
      matrixCache :: Map (Matrix M (Exp (Complex Double))) CExp
    }

defaultCgState :: CgState
defaultCgState = CgState
    { code        = mempty
    , matrixCache = mempty
    }

-- | The 'Cg' monad transformer.
newtype Cg m a = Cg { unCg :: StateT CgState m a }
    deriving (Functor, Applicative, Monad, MonadIO,
              MonadException,
              MonadState CgState,
              MonadUnique,
              MonadTrace,
              MonadConfig)

instance MonadTrans Cg where
    lift = Cg . lift

-- | Evaluate a 'Cg' action and return a list of 'C.Definition's.
evalCg :: Monad m => Cg m () -> m (Seq C.Definition)
evalCg m = do
    s <- execStateT (unCg m) defaultCgState
    return $ (codeDefs . code) s <> (codeFunDefs . code) s

-- | Add generated code.
tell :: Monad m => Code -> Cg m ()
tell c = modify $ \s -> s { code = code s <> c }

-- | Collect code generated by a computation.
collect :: Monad m => Cg m a -> Cg m (Code, a)
collect m = do
    old_code <- gets code
    modify $ \s -> s { code = mempty }
    x <- m
    c <- gets code
    modify $ \s -> s { code = old_code }
    return (c, x)

-- | Collect definitions generated by a computation.
collectDefinitions :: Monad m => Cg m a -> Cg m ([C.Definition], a)
collectDefinitions m = do
    (c, x) <- collect m
    tell c { codeDefs = mempty }
    return (toList (codeDefs c), x)

-- | Collect definitions generated by a unit computation.
collectDefinitions_ :: Monad m => Cg m () -> Cg m [C.Definition]
collectDefinitions_ m = fst <$> collectDefinitions m

-- | Collect declarations generated by a computation.
collectDecls :: Monad m => Cg m a -> Cg m ([C.InitGroup], a)
collectDecls m = do
    (c, x) <- collect m
    tell c { codeDecls = mempty }
    return (toList (codeDecls c), x)

-- | Collect declarations generated by a unit computation.
collectDecls_ :: Monad m => Cg m () -> Cg m [C.InitGroup]
collectDecls_ m = fst <$> collectDecls m

-- | Collect statements generated by a computation.
collectStms :: Monad m => Cg m a -> Cg m ([C.Stm], a)
collectStms m = do
    (c, x) <- collect m
    tell c { codeStms = mempty }
    return (toList (codeStms c), x)

-- | Collect statements generated by a unit computation.
collectStms_ :: Monad m => Cg m () -> Cg m [C.Stm]
collectStms_ m = fst <$> collectStms m

-- | Collect a block of code generated by a computation.
collectBlock :: Monad m => Cg m a -> Cg m (Seq C.InitGroup, Seq C.Stm, a)
collectBlock m = do
    (c, x) <- collect m
    tell c { codeDecls = mempty
           , codeStms  = mempty
           }
    return (codeDecls c, codeStms c, x)

inNewBlock :: Monad m => Cg m a -> Cg m ([C.BlockItem], a)
inNewBlock m = do
    (decls, stms, x) <- collectBlock m
    return ((map C.BlockDecl . toList) decls ++
            (map C.BlockStm .  toList) stms
           ,x)

inNewBlock_ :: Monad m => Cg m a -> Cg m [C.BlockItem]
inNewBlock_ m =
    fst <$> inNewBlock m

-- | Append a top-level definition.
appendTopDef :: Monad m => C.Definition -> Cg m ()
appendTopDef cdef =
  tell mempty { codeDefs = Seq.singleton cdef }

-- | Append top-level definitions.
appendTopDefs :: Monad m => [C.Definition] -> Cg m ()
appendTopDefs cdefs =
  tell mempty { codeDefs = Seq.fromList cdefs }

-- | Append a top-level function definition. Function definitions appear after
-- regular top-level definitions.
appendTopFunDef :: Monad m => C.Definition -> Cg m ()
appendTopFunDef cdef =
  tell mempty { codeFunDefs = Seq.singleton cdef }

-- | Append top-level functions definitions.
appendTopFunDefs :: Monad m => [C.Definition] -> Cg m ()
appendTopFunDefs cdefs =
  tell mempty { codeFunDefs = Seq.fromList cdefs }

appendTopDecl :: Monad m => C.InitGroup -> Cg m ()
appendTopDecl cdecl =
  tell mempty { codeDefs = Seq.singleton (C.DecDef cdecl noLoc) }

appendTopDecls :: Monad m => [C.InitGroup] -> Cg m ()
appendTopDecls cdecls =
  tell mempty { codeDefs = Seq.fromList [C.DecDef decl noLoc | decl <- cdecls] }

appendDecl :: Monad m => C.InitGroup -> Cg m ()
appendDecl cdecl = tell mempty { codeDecls = Seq.singleton cdecl }

appendDecls :: Monad m => [C.InitGroup] -> Cg m ()
appendDecls cdecls = tell mempty { codeDecls = Seq.fromList cdecls }

appendStm :: Monad m => C.Stm -> Cg m ()
appendStm cstm = tell mempty { codeStms = Seq.singleton cstm }

appendStms :: Monad m => [C.Stm] -> Cg m ()
appendStms cstms = tell mempty { codeStms = Seq.fromList cstms }

appendBlock :: Monad m => [C.BlockItem] -> Cg m ()
appendBlock citems
    | all isBlockStm citems = appendStms [stm | C.BlockStm stm <- citems]
    | otherwise             = appendStm [cstm|{ $items:citems }|]
  where
    isBlockStm :: C.BlockItem -> Bool
    isBlockStm C.BlockStm{} = True
    isBlockStm _            = False

lookupMatrix :: Monad m => Matrix M (Exp (Complex Double)) -> Cg m (Maybe CExp)
lookupMatrix m = gets (Map.lookup m . matrixCache)

cacheMatrix :: Monad m => Matrix M (Exp (Complex Double)) -> CExp -> Cg m ()
cacheMatrix mat ce =
    modify $ \s -> s { matrixCache = Map.insert mat ce (matrixCache s) }
