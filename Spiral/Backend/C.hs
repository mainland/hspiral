{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}

-- |
-- Module      :  Spiral.Backend.C
-- Copyright   :  (c) 2016 Drexel University
-- License     :  BSD-style
-- Maintainer  :  mainland@drexel.edu

module Spiral.Backend.C (
    Cg,
    evalCg,

    tell,
    collect,
    collectDefinitions,
    collectDefinitions_,
    collectDecls,
    collectDecls_,
    collectStms,
    collectStms_,
    collectBlock,

    inNewBlock,
    inNewBlock_,

    appendTopDef,
    appendTopDefs,
    appendTopFunDef,
    appendTopFunDefs,
    appendTopDecl,
    appendTopDecls,
    appendDecl,
    appendDecls,
    appendStm,
    appendStms,
    appendBlock
  ) where

import Control.Monad.Exception (MonadException(..))
import Control.Monad.IO.Class (MonadIO)
import Control.Monad.Trans.Class (MonadTrans(..))
import Control.Monad.State (MonadState(..),
                            StateT,
                            execStateT,
                            gets,
                            modify)
import Data.Complex
import Data.Foldable (toList)
import Data.Loc (noLoc)
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Monoid
import Data.Sequence (Seq)
import qualified Data.Sequence as Seq
import Language.C.Pretty ()
import qualified Language.C.Syntax as C
import Language.C.Quote.C

import Spiral.Backend.C.CExp
import Spiral.Backend.C.Code
import Spiral.Backend.C.Util
import qualified Spiral.Cg.Monad as Cg
import Spiral.Cg.Monad (CVec(..),
                        cgExp)
import Spiral.Config
import Spiral.Exp
import Spiral.SPL
import Spiral.Trace
import Spiral.Util.Lift
import Spiral.Util.Uniq

data CgState = CgState
    { -- | Generated code
      code :: Code
    , -- | Cached matrices
      matrixCache :: Map (Matrix M (Exp (Complex Double))) CExp
    }

defaultCgState :: CgState
defaultCgState = CgState
    { code        = mempty
    , matrixCache = mempty
    }

-- | The 'Cg' monad transformer.
newtype Cg m a = Cg { unCg :: StateT CgState m a }
    deriving (Functor, Applicative, Monad, MonadIO,
              MonadException,
              MonadState CgState,
              MonadUnique,
              MonadTrace,
              MonadConfig)

instance MonadTrans Cg where
    lift = Cg . lift

-- | Evaluate a 'Cg' action and return a list of 'C.Definition's.
evalCg :: Monad m => Cg m () -> m (Seq C.Definition)
evalCg m = do
    s <- execStateT (unCg m) defaultCgState
    return $ (codeDefs . code) s <> (codeFunDefs . code) s

-- | Add generated code.
tell :: Monad m => Code -> Cg m ()
tell c = modify $ \s -> s { code = code s <> c }

-- | Collect code generated by a computation.
collect :: Monad m => Cg m a -> Cg m (Code, a)
collect m = do
    old_code <- gets code
    modify $ \s -> s { code = mempty }
    x <- m
    c <- gets code
    modify $ \s -> s { code = old_code }
    return (c, x)

-- | Collect definitions generated by a computation.
collectDefinitions :: Monad m => Cg m a -> Cg m ([C.Definition], a)
collectDefinitions m = do
    (c, x) <- collect m
    tell c { codeDefs = mempty }
    return (toList (codeDefs c), x)

-- | Collect definitions generated by a unit computation.
collectDefinitions_ :: Monad m => Cg m () -> Cg m [C.Definition]
collectDefinitions_ m = fst <$> collectDefinitions m

-- | Collect declarations generated by a computation.
collectDecls :: Monad m => Cg m a -> Cg m ([C.InitGroup], a)
collectDecls m = do
    (c, x) <- collect m
    tell c { codeDecls = mempty }
    return (toList (codeDecls c), x)

-- | Collect declarations generated by a unit computation.
collectDecls_ :: Monad m => Cg m () -> Cg m [C.InitGroup]
collectDecls_ m = fst <$> collectDecls m

-- | Collect statements generated by a computation.
collectStms :: Monad m => Cg m a -> Cg m ([C.Stm], a)
collectStms m = do
    (c, x) <- collect m
    tell c { codeStms = mempty }
    return (toList (codeStms c), x)

-- | Collect statements generated by a unit computation.
collectStms_ :: Monad m => Cg m () -> Cg m [C.Stm]
collectStms_ m = fst <$> collectStms m

-- | Collect a block of code generated by a computation.
collectBlock :: Monad m => Cg m a -> Cg m (Seq C.InitGroup, Seq C.Stm, a)
collectBlock m = do
    (c, x) <- collect m
    tell c { codeDecls = mempty
           , codeStms  = mempty
           }
    return (codeDecls c, codeStms c, x)

inNewBlock :: Monad m => Cg m a -> Cg m ([C.BlockItem], a)
inNewBlock m = do
    (decls, stms, x) <- collectBlock m
    return ((map C.BlockDecl . toList) decls ++
            (map C.BlockStm .  toList) stms
           ,x)

inNewBlock_ :: Monad m => Cg m a -> Cg m [C.BlockItem]
inNewBlock_ m =
    fst <$> inNewBlock m

-- | Append a top-level definition.
appendTopDef :: Monad m => C.Definition -> Cg m ()
appendTopDef cdef =
  tell mempty { codeDefs = Seq.singleton cdef }

-- | Append top-level definitions.
appendTopDefs :: Monad m => [C.Definition] -> Cg m ()
appendTopDefs cdefs =
  tell mempty { codeDefs = Seq.fromList cdefs }

-- | Append a top-level function definition. Function definitions appear after
-- regular top-level definitions.
appendTopFunDef :: Monad m => C.Definition -> Cg m ()
appendTopFunDef cdef =
  tell mempty { codeFunDefs = Seq.singleton cdef }

-- | Append top-level functions definitions.
appendTopFunDefs :: Monad m => [C.Definition] -> Cg m ()
appendTopFunDefs cdefs =
  tell mempty { codeFunDefs = Seq.fromList cdefs }

appendTopDecl :: Monad m => C.InitGroup -> Cg m ()
appendTopDecl cdecl =
  tell mempty { codeDefs = Seq.singleton (C.DecDef cdecl noLoc) }

appendTopDecls :: Monad m => [C.InitGroup] -> Cg m ()
appendTopDecls cdecls =
  tell mempty { codeDefs = Seq.fromList [C.DecDef decl noLoc | decl <- cdecls] }

appendDecl :: Monad m => C.InitGroup -> Cg m ()
appendDecl cdecl = tell mempty { codeDecls = Seq.singleton cdecl }

appendDecls :: Monad m => [C.InitGroup] -> Cg m ()
appendDecls cdecls = tell mempty { codeDecls = Seq.fromList cdecls }

appendStm :: Monad m => C.Stm -> Cg m ()
appendStm cstm = tell mempty { codeStms = Seq.singleton cstm }

appendStms :: Monad m => [C.Stm] -> Cg m ()
appendStms cstms = tell mempty { codeStms = Seq.fromList cstms }

appendBlock :: Monad m => [C.BlockItem] -> Cg m ()
appendBlock citems
    | all isBlockStm citems = appendStms [stm | C.BlockStm stm <- citems]
    | otherwise             = appendStm [cstm|{ $items:citems }|]
  where
    isBlockStm :: C.BlockItem -> Bool
    isBlockStm C.BlockStm{} = True
    isBlockStm _            = False

lookupMatrix :: Monad m => Matrix M (Exp (Complex Double)) -> Cg m (Maybe CExp)
lookupMatrix m = gets (Map.lookup m . matrixCache)

cacheMatrix :: Monad m => Matrix M (Exp (Complex Double)) -> CExp -> Cg m ()
cacheMatrix mat ce =
    modify $ \s -> s { matrixCache = Map.insert mat ce (matrixCache s) }

cvar :: MonadUnique m => String -> Cg m C.Id
cvar = gensym

cgMatrix :: forall m . (MonadConfig m, MonadTrace m, MonadUnique m)
         => Matrix M (Exp (Complex Double))
         -> Cg m CExp
cgMatrix mat = do
    maybe_ce <- lookupMatrix mat
    case maybe_ce of
      Just ce -> return ce
      Nothing -> do ce <- cgMat
                    cacheMatrix mat ce
                    return ce
  where
    Z :. m :. n = extent mat
    ess = toLists mat

    cgRow :: [Exp (Complex Double)] -> Cg m CExp
    cgRow es = do
        ces <- mapM cgExp es
        return $ CInit [cinit|{ $inits:(map toInitializer ces) }|]

    cgMat :: Cg m CExp
    cgMat = do
      cmat  <- cvar "mat"
      crows <- mapM cgRow ess
      appendTopDecl [cdecl|static const double _Complex $id:cmat[$int:m][$int:n] = { $inits:(map toInitializer crows) };|]
      return $ CExp [cexp|$id:cmat|]

instance (MonadConfig m, MonadTrace m, MonadUnique m) => Cg.MonadCg (Cg m) where
     type CExp (Cg m) = CExp

     cgTransform name (Z :. m :. n) k = do
        appendTopDef [cedecl|$esc:("#include <complex.h>")|]
        cin   <- cvar "in"
        cout  <- cvar "out"
        items <- inNewBlock_ $
                 k (CVec (CExp [cexp|$id:cin|])  0 1 n)
                   (CVec (CExp [cexp|$id:cout|]) 0 1 m)
        appendTopFunDef [cedecl|
void $id:name(restrict double _Complex $id:cout[static $int:m],
              restrict const double _Complex $id:cin[static $int:n])
{
    $items:items
}|]

     cgExp (IntC x)      = return $ CInt x
     cgExp (DoubleC x)   = return $ CDouble (toRational x)
     cgExp (RationalC x) = return $ CDouble x

     cgExp (ComplexC e1 e2) = do
         ce1 <- cgExp e1
         ce2 <- cgExp e2
         go ce1 ce2
       where
         go :: CExp -> CExp -> Cg m CExp
         go ce1 ce2
           | isZero e1 && isOne e2    = return $ CExp [cexp|I|]
           | isZero e1 && isNegOne e2 = return $ CExp [cexp|-I|]
           | isZero e1                = return $ CExp [cexp|$ce2 * I|]
           | isZero e2                = return ce1
           | otherwise                = return $ CExp [cexp|$ce1 + $ce2 * I|]

     cgExp e@RouC{} = cgExp (toComplex e)

     cgTemp = fail "cgTemp: Can't generate temp"

     cgIdx e (CInt i, CInt j) =
         cgExp $ e ! ix2 (fromInteger i) (fromInteger j)

     cgIdx e (ci, cj) = do
         cmat <- cgMatrix $ manifest e
         return $ CExp [cexp|$cmat[$ci][$cj]|]

     cgVIdx (CVec cv off stride _end) ci =
         return $ CExp [cexp|$cv[$(fromIntegral off + ci*fromIntegral stride)]|]

     cgAssign ce1 ce2 =
         appendStm [cstm|$ce1 = $ce2;|]

     cgFor lo hi k = do
         maxun <- asksConfig maxUnroll
         if hi - lo <= maxun
           then mapM_ k [CInt (fromIntegral i) | i <- [lo..hi-1::Int]]
           else do
             ci    <- cvar "i"
             items <- inNewBlock_ $ k (CExp [cexp|$id:ci|])
             appendStm [cstm|for (int $id:ci = $int:lo; $id:ci < $int:hi; ++$id:ci) $stm:(toStm items)|]
